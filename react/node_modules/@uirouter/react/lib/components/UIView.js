"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var _a;
/**
 * @reactapi
 * @module components
 */ /** */
var React = require("react");
var react_1 = require("react");
var PropTypes = require("prop-types");
var core_1 = require("@uirouter/core");
var index_1 = require("../index");
var UIRouter_1 = require("./UIRouter");
/** @internalapi */
var id = 0;
exports.TransitionPropCollisionError = new Error('`transition` cannot be used as resolve token. ' +
    'Please rename your resolve to avoid conflicts with the router transition.');
/** @internalapi */
exports.UIViewProvider = (_a = React.createContext(undefined), _a.Provider), exports.UIViewConsumer = _a.Consumer;
var View = /** @class */ (function (_super) {
    __extends(View, _super);
    function View() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.state = {
            loaded: false,
            component: 'div',
            props: {},
        };
        return _this;
    }
    View.prototype.render = function () {
        var _this = this;
        var _a = this.props, children = _a.children, render = _a.render;
        var _b = this.state, component = _b.component, props = _b.props, loaded = _b.loaded;
        // register reference of child component
        // register new hook right after component has been rendered
        var stateName = this.uiViewAddress && this.uiViewAddress.context && this.uiViewAddress.context.name;
        // only class components can implement the
        // uiCanExit hook and ref doesn't work on
        // stateless function components
        if (typeof component !== 'string' &&
            (!!component.render || (component.prototype && !!component.prototype.render))) {
            props.ref = function (c) {
                _this.componentInstance = c;
                _this.registerUiCanExitHook(stateName);
            };
        }
        // attach any style or className to the rendered component
        // specified on the UIView itself
        var _c = this.props, className = _c.className, style = _c.style;
        var styleProps = { className: className, style: style };
        var childProps = __assign({}, props, styleProps);
        var child = !loaded && react_1.isValidElement(children) ? react_1.cloneElement(children, childProps) : react_1.createElement(component, childProps);
        // if a render function is passed use that,
        // otherwise render the component normally
        var ChildOrRenderFunction = typeof render !== 'undefined' && loaded ? render(component, childProps) : child;
        return React.createElement(exports.UIViewProvider, { value: this.uiViewAddress }, ChildOrRenderFunction);
    };
    View.prototype.componentWillMount = function () {
        var router = this.props.router;
        if (typeof router === 'undefined') {
            throw UIRouter_1.UIRouterInstanceUndefinedError;
        }
        // Check the context for the parent UIView's fqn and State
        var parent = this.props.parentUIView;
        // Not found in context, this is a root UIView
        parent = parent || { fqn: '', context: router.stateRegistry.root() };
        var name = this.props.name || '$default';
        this.uiViewData = {
            $type: 'react',
            id: ++id,
            name: name,
            fqn: parent.fqn ? parent.fqn + '.' + name : name,
            creationContext: parent.context,
            configUpdated: this.viewConfigUpdated.bind(this),
            config: undefined,
        };
        this.uiViewAddress = { fqn: this.uiViewData.fqn, context: undefined };
        this.deregister = router.viewService.registerUIView(this.uiViewData);
        this.setState({ id: this.uiViewData.id });
    };
    View.prototype.componentWillUnmount = function () {
        this.deregister();
    };
    /**
     * View config updated callback
     *
     * This is called by UI-Router during ViewService.sync().
     * The `newConfig` parameter will contain view configuration (component, etc) when a
     * state is activated and one of its views targets this `UIView`.
     */
    View.prototype.viewConfigUpdated = function (newConfig) {
        if (newConfig === this.uiViewData.config) {
            return;
        }
        var trans;
        var resolves = {};
        if (newConfig) {
            var viewContext = newConfig.viewDecl && newConfig.viewDecl.$context;
            this.uiViewAddress = {
                fqn: this.uiViewAddress.fqn,
                context: viewContext,
            };
            var resolveContext = new core_1.ResolveContext(newConfig.path);
            var injector_1 = resolveContext.injector();
            var stringTokens = resolveContext.getTokens().filter(function (x) { return typeof x === 'string'; });
            if (stringTokens.indexOf('transition') !== -1) {
                throw exports.TransitionPropCollisionError;
            }
            trans = injector_1.get(core_1.Transition);
            resolves = stringTokens.map(function (token) { return [token, injector_1.get(token)]; }).reduce(core_1.applyPairs, {});
        }
        this.uiViewData.config = newConfig;
        var key = Date.now();
        var props = __assign({}, resolves, { transition: trans, key: key });
        var newComponent = newConfig && newConfig.viewDecl && newConfig.viewDecl.component;
        this.setState({
            component: newComponent || 'div',
            props: newComponent ? props : {},
            loaded: !!newComponent,
        });
    };
    View.prototype.registerUiCanExitHook = function (stateName) {
        typeof this.removeHook === 'function' && this.removeHook();
        var criteria = { exiting: stateName };
        var callback = this.componentInstance &&
            typeof this.componentInstance.uiCanExit === 'function' &&
            this.componentInstance.uiCanExit;
        if (stateName && callback) {
            var transitions = this.props.router.transitionService;
            this.removeHook = transitions.onBefore(criteria, callback, {});
        }
    };
    View.propTypes = {
        router: PropTypes.object.isRequired,
        parentUIView: PropTypes.object,
        name: PropTypes.string,
        className: PropTypes.string,
        style: PropTypes.object,
        render: PropTypes.func,
    };
    return View;
}(react_1.Component));
var UIView = /** @class */ (function (_super) {
    __extends(UIView, _super);
    function UIView() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    UIView.prototype.render = function () {
        var _this = this;
        return (React.createElement(index_1.UIRouterConsumer, null, function (router) { return (React.createElement(exports.UIViewConsumer, null, function (parentUIView) { return React.createElement(View, __assign({}, _this.props, { router: router, parentUIView: parentUIView })); })); }));
    };
    UIView.displayName = 'UIView';
    UIView.__internalViewComponent = View;
    return UIView;
}(React.Component));
exports.UIView = UIView;
//# sourceMappingURL=UIView.js.map
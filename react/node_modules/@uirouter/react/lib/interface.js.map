{
  "version": 3,
  "file": "interface.js",
  "sourceRoot": "",
  "sources": [
    "@uirouter/react/interface.tsx"
  ],
  "names": [],
  "mappings": "",
  "sourcesContent": [
    "/**\n * @reactapi\n * @module react\n */ /** */\nimport { Component, ReactElement, StatelessComponent, ComponentClass, ClassicComponentClass } from 'react';\n\nimport { StateDeclaration, _ViewDeclaration, ParamDeclaration, IInjectable, Transition } from '@uirouter/core';\n\n/**\n * The StateDeclaration object is used to define a state or nested state.\n * It should be registered with the [[StateRegistry]].\n *\n * #### Example:\n * ```js\n * import {FoldersComponent} from \"./folders\";\n *\n * // StateDeclaration object\n * var foldersState = {\n *   name: 'folders',\n *   url: '/folders',\n *   component: FoldersComponent,\n *   resolve: {\n *     allfolders: function(FolderService) {\n *       return FolderService.list();\n *     }\n *   }\n * }\n * ```\n */\nexport interface ReactStateDeclaration extends StateDeclaration, ReactViewDeclaration {\n  /**\n   * An optional object used to define multiple named views.\n   *\n   * Each key is the name of a view, and each value is a [[Ng2ViewDeclaration]].\n   * Unnamed views are internally renamed to `$default`.\n   *\n   * A view's name is used to match an active `<ui-view>` directive in the DOM.  When the state\n   * is entered, the state's views are activated and then matched with active `<ui-view>` directives:\n   *\n   * - The view's name is processed into a ui-view target:\n   *   - ui-view address: an address to a ui-view\n   *   - state anchor: the state to anchor the address to\n   *\n   *  Examples:\n   *\n   *  Targets three named ui-views in the parent state's template\n   *\n   * #### Example:\n   * ```js\n   * views: {\n   *   header: HeaderComponent,\n   *   body: BodyComponent,\n   *   footer: FooterComponent\n   * }\n   * ```\n   *\n   * #### Example:\n   * ```js\n   * // Targets named ui-view=\"header\" in the template of the ancestor state 'top'\n   * // and the named `ui-view=\"body\" from the parent state's template.\n   * views: {\n   *   'header@top': MsgHeaderComponent,\n   *   'body': MessagesComponent\n   * }\n   * ```\n   *\n   * ## View targeting details\n   *\n   * There are a few styles of view addressing/targeting.  The most common is a simple `ui-view` name\n   *\n   *\n   * #### Simple ui-view name\n   *\n   * Addresses without an `@` are anchored to the parent state.\n   *\n   * #### Example:\n   * ```js\n   * // target the `<div ui-view='foo'></div>` created in the parent state's view\n   * views: { foo: {...} }\n   * ```\n   *\n   * #### View name anchored to a state\n   *\n   * You can anchor the `ui-view` name to a specific state by including an `@`\n   *\n   * #### Example:\n   * ```js\n   *\n   * // target the `<div ui-view='foo'></div>` which was created in a\n   * // view owned by the state `bar.baz`\n   * views: { 'foo@bar.baz': {...} }\n   * ```\n   *\n   * #### Absolute addressing\n   *\n   * You can address a `ui-view` absolutely, using dotted notation, by prefixing the address with a `!`.  Dotted\n   * addresses map to the hierarchy of `ui-view`s active in the DOM:\n   *\n   * #### Example:\n   * ```js\n   * // absolutely target the `<div ui-view='nested'></div>`... which was created\n   * // in the unnamed/$default root `<ui-view></ui-view>`\n   * views: { '!$default.nested': {...} }\n   * ```\n   *\n   * #### Relative addressing\n   *\n   * Absolute addressing is actually relative addressing, only anchored to the unnamed root state.  You can also use\n   * relative addressing anchored to any state, in order to target a target deeply nested `ui-views`:\n   *\n   * #### Example:\n   * ```js\n   * // target the `<div ui-view='bar'></div>`... which was created inside the\n   * // `<div ui-view='bar'></div>`... which was created inside the parent state's template.\n   * views: { 'foo.bar': {...} }\n   * ```\n   *\n   * #### Example:\n   * ```js\n   * // target the `<div ui-view='bar'></div>`...  which was created in\n   * // `<div ui-view='foo'></div>`... which was created in a template crom the state `baz.qux`\n   * views: { 'foo.bar@baz.qux': {...} }\n   *\n   * ---\n   *\n   * ## State `component:` and `views:` incompatiblity\n   *\n   * If a state has a `views` object, the state-level `component:` property is ignored.  Therefore,\n   * if _any view_ for a state is declared in the `views` object, then _all of the state's views_ must be defined in\n   * the `views` object.\n   */\n  views?: { [key: string]: ReactViewDeclaration };\n}\n\n/**\n * Declares a view on some state\n */\nexport interface ReactViewDeclaration extends _ViewDeclaration {\n  /**\n   * The React `Component` to use for this view.\n   *\n   * A property of [[ReactStateDeclaration]] or [[ReactViewDeclaration]]:\n   *\n   * The React Component which will be used for this view.\n   *\n   * Resolve data can be provided to the component using props.\n   *\n   * TODO: document react shorthand, like ng1's shorthand: inside a \"views:\" block, a bare string `\"foo\"` is shorthand for `{ component: \"foo\" }`\n   *\n   * #### Example:\n   * ```js\n   * .state('profile', {\n   *   // Use the <my-profile></my-profile> component for the Unnamed view\n   *   component: MyProfileComponent,\n   * }\n   *\n   * .state('messages', {\n   *   // use the <nav-bar></nav-bar> component for the view named 'header'\n   *   // use the <message-list></message-list> component for the view named 'content'\n   *   views: {\n   *     header: { component: NavBar },\n   *     content: { component: MessageList }\n   *   }\n   * }\n   *\n   * .state('contacts', {\n   *   // Inside a \"views:\" block, supplying only a Component class is shorthand for { component: NavBar }\n   *   // use the <nav-bar></nav-bar> component for the view named 'header'\n   *   // use the <contact-list></contact-list> component for the view named 'content'\n   *   views: {\n   *     header: NavBar,\n   *     content: ContactList\n   *   }\n   * }\n   * ```\n   */\n  component?: StatelessComponent<any> | ComponentClass<any> | ClassicComponentClass<any>;\n\n  /**\n   * @hidden\n   *\n   * An object which maps `resolve`s to [[component]] `bindings`.\n   *\n   * A property of [[Ng2StateDeclaration]] or [[Ng2ViewDeclaration]]:\n   *\n   * When using a [[component]] declaration (`component: 'myComponent'`), each input binding for the component is supplied\n   * data from a resolve of the same name, by default.  You may supply data from a different resolve name by mapping it here.\n   *\n   * Each key in this object is the name of one of the component's input bindings.\n   * Each value is the name of the resolve that should be provided to that binding.\n   *\n   * Any component bindings that are omitted from this map get the default behavior of mapping to a resolve of the\n   * same name.\n   *\n   * #### Example:\n   * ```js\n   * $stateProvider.state('foo', {\n   *   resolve: {\n   *     foo: function(FooService) { return FooService.get(); },\n   *     bar: function(BarService) { return BarService.get(); }\n   *   },\n   *   component: 'Baz',\n   *   // The component's `baz` binding gets data from the `bar` resolve\n   *   // The component's `foo` binding gets data from the `foo` resolve (default behavior)\n   *   bindings: {\n   *     baz: 'bar'\n   *   }\n   * });\n   *\n   * app.component('Baz', {\n   *   templateUrl: 'baz.html',\n   *   controller: 'BazController',\n   *   bindings: {\n   *     foo: '<', // foo binding\n   *     baz: '<'  // baz binding\n   *   }\n   * });\n   * ```\n   *\n   */\n  // bindings?: { [key: string]: string };\n}\n\n/**\n * The shape of a controller for a view (and/or component), defining the controller callbacks.\n *\n * A view in UI-Router is comprised of either a `component` ([[Ng2ViewDeclaration.component]]) or a combination of a\n * `template` (or `templateProvider`) and a `controller` (or `controllerProvider`).\n *\n * The `controller` object (or the `component`'s controller object) can define component-level controller callbacks,\n * which UI-Router will call at the appropriate times.  These callbacks are similar to Transition Hooks\n * ([[IHookRegistry]]), but are only called if the view is currently active.\n *\n * This interface defines the UI-Router component callbacks.\n *\n * TODO: this should extend the ng2 Component interface\n */\nexport interface ReactComponent {\n  /**\n   * This callback is called when parameter values have changed.\n   *\n   * This callback can be used to respond to changing parameter values in the current state, or in parent/child states.\n   * This callback is especially handy when using dynamic parameters ([[ParamDeclaration.dynamic]])\n   *\n   * Called when:\n   * - The view is still active\n   * - A new transition has completed successfully\n   * - The state for the view (controller) was not reloaded\n   * - At least one parameter value was changed\n   *\n   * Called with:\n   * @param newValues an object containing the changed parameter values\n   * @param $transition$ the new Transition which triggered this callback\n   *\n   * #### Example:\n   * ```js\n   * angular.module('foo').controller('FancyCtrl', function() {\n   *   this.uiOnParamsChanged = function(newParams) {\n   *     console.log(\"new params: \", newParams);\n   *   }\n   * });\n   * ```\n   */\n  uiOnParamsChanged(newValues: any, $transition$: Transition);\n\n  /**\n   * This callback is called when the view's state is about to be exited.\n   *\n   * This callback is used to inform a view that it is about to be exited, due to a new [[Transition]].\n   * The callback can ask for user confirmation, and cancel or alter the new Transition.  The callback should\n   * return a value, or a promise for a value.  If a promise is returned, the new Transition waits until the\n   * promise settles.\n   *\n   *\n   * Called when:\n   * - The view is still active\n   * - A new Transition is about to run\n   * - The new Transition will exit the view's state\n   *\n   * Called with:\n   * - This callback is injected in the new Transition's context\n   *\n   * Relevant return Values:\n   * - `false`: The transition is cancelled.\n   * - A rejected promise: The transition is cancelled.\n   * - [[TargetState]]: The transition is redirected to the new target state.\n   * - Anything else: the transition will continue normally (the state and view will be deactivated)\n   *\n   * @return a value, or a promise for a value.\n   */\n  uiCanExit();\n}\n"
  ]
}